<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>YouTube DJ Player ‚Äî Fixed Modals & Bugs</title>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>

  <style>
    :root{ --bg1:#071019; --accent:#ff6a2b; --muted:#93a3ad; --panel-radius:12px; --footer-h:72px; }
    *{box-sizing:border-box;font-family:Inter,Arial,sans-serif}
    html,body{height:100%;margin:0;background:linear-gradient(135deg,#071019,#071827);color:#ecf6ff;padding:18px;padding-bottom:calc(var(--footer-h)+28px)}
    .wrap{max-width:1180px;margin:0 auto}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:14px}
    h1{margin:0;color:var(--accent);font-size:18px}
    .small{font-size:12px;color:var(--muted)}
    .card{background:linear-gradient(180deg,#04101a,#061524);border-radius:var(--panel-radius);padding:12px;border:1px solid rgba(255,255,255,0.03)}
    .search-row{display:flex;gap:12px;margin-bottom:12px}
    .search-box{flex:1;display:flex;gap:8px;align-items:center}
    input[type=text], input[type=search], select, textarea{padding:10px;border-radius:10px;background:transparent;border:1px solid rgba(255,255,255,0.03);color:inherit}
    button{background:linear-gradient(180deg,var(--accent),#ff8f4d);border:0;color:#061018;padding:8px 10px;border-radius:8px;cursor:pointer}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
    .deck-row{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:760px){ .deck-row{grid-template-columns:1fr} .search-row{flex-direction:column} }
    .player-area{position:relative;background:#000;border-radius:10px;min-height:220px;overflow:visible}
    iframe{width:100%;height:100%;border:0;display:block}
    .deck-audio-ui{position:absolute;left:0;right:0;top:0;bottom:0;padding:12px;display:flex;flex-direction:column;justify-content:center;gap:8px;background:linear-gradient(180deg,rgba(0,0,0,0.55),rgba(0,0,0,0.45))}
    .hidden{display:none!important}
    .dropdown{position:absolute;top:10px;left:12px;max-height:320px;overflow:auto;z-index:999;background:#071726;border-radius:10px;padding:8px;box-shadow:0 10px 30px rgba(0,0,0,0.6);display:none}
    .dropdown .item{display:flex;gap:8px;align-items:center;padding:8px;border-radius:6px;cursor:pointer}
    .dropdown .item:hover{background:rgba(255,255,255,0.02)}
    .tag{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:999px;font-size:12px}
    .footer-tabs{position:fixed;left:12px;right:12px;bottom:12px;height:var(--footer-h);display:flex;gap:8px;align-items:center;justify-content:center;background:rgba(3,6,10,0.95);padding:8px;border-radius:10px;z-index:9999}
    .list{max-height:60vh;overflow:auto;padding:8px}
    .history-row{display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:8px;background:linear-gradient(180deg,transparent,rgba(255,255,255,0.01));margin-bottom:8px;border:1px solid rgba(255,255,255,0.02)}
    .muted{color:var(--muted)}
    .bpm-row{display:flex;gap:8px;align-items:center;margin-top:8px}
    .bpm-value{font-weight:700;color:var(--accent);min-width:44px;text-align:center}
    .tempo-slider{width:100%}
    /* Modal baseline rules so display:flex works reliably */
    .modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.72);z-index:10000;align-items:center;justify-content:center;padding:18px}
    .panel{max-width:1100px;width:100%;max-height:90vh;overflow:auto}
    .close-x{background:transparent;border:0;color:var(--muted);cursor:pointer;font-size:16px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>SAMMY'S YT DJ (fixed)</h1>
        <div class="small">Modals, dropdowns, BPM & MP3/YouTube switching ‚Äî fixed and hardened.</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn-ghost" id="open-notes-btn">Notes</button>
        <button class="btn-ghost" id="open-chat-btn">Chatbot</button>
        <button id="add-mp3-btn">Add MP3</button>
        <input id="mp3-input" type="file" accept=".mp3,audio/*" style="display:none" />
      </div>
    </header>

    <!-- SEARCH ROW -->
    <div class="card search-row">
      <div class="search-box">
        <input id="search-deck1" type="search" placeholder="Search YouTube for Deck 1 (press Enter or click Search)">
        <button id="search-btn-1">Search Deck 1</button>
      </div>
      <div class="search-box">
        <input id="search-deck2" type="search" placeholder="Search YouTube for Deck 2 (press Enter or click Search)">
        <button id="search-btn-2">Search Deck 2</button>
      </div>
    </div>

    <main>
      <div class="card deck-row">
        <!-- Deck 1 -->
        <div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div><strong>DECK 1</strong><div class="small">YouTube or MP3</div></div>
            <div class="tag" id="tag-deck1">YT</div>
          </div>
          <div class="player-area" id="player-area-1">
            <iframe id="youtube-player1" src="https://www.youtube.com/embed?enablejsapi=1&playsinline=1&disablekb=1" allow="autoplay"></iframe>

            <div class="deck-audio-ui hidden" id="deck-audio-ui-1">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <div id="deck1-title" class="small">Local MP3</div>
                <div class="small" id="deck1-duration">0:00</div>
              </div>
              <div style="display:flex;gap:8px;align-items:center">
                <button id="deck1-playbtn">‚ñ∂</button>
                <input id="deck1-seek" type="range" min="0" max="100" value="0" style="flex:1">
                <input id="deck1-volume" type="range" min="0" max="100" value="80" style="width:120px">
              </div>
              <div style="display:flex;justify-content:space-between;align-items:center">
                <div class="small" id="deck1-current">0:00</div>
                <div style="display:flex;gap:6px"><button class="btn-ghost" id="deck1-lowcut">Low-cut</button></div>
              </div>
            </div>

            <!-- BPM controls -->
            <div style="position:absolute;left:12px;right:12px;bottom:12px;display:flex;justify-content:space-between;align-items:center;gap:12px">
              <div style="flex:1;display:flex;flex-direction:column">
                <label class="small">BPM</label>
                <div class="bpm-row">
                  <input id="tempo1" class="tempo-slider" type="range" min="60" max="180" step="1" value="120">
                  <div id="tempo1-value" class="bpm-value">120</div>
                </div>
              </div>
              <div style="display:flex;flex-direction:column;align-items:flex-end">
                <div class="small muted">Deck 1</div>
                <div style="display:flex;gap:8px;margin-top:6px">
                  <button class="btn-ghost" id="reset-bpm-1">Reset BPM</button>
                </div>
              </div>
            </div>

            <div id="custom-dropdown1" class="dropdown" role="listbox" aria-hidden="true"></div>
          </div>
        </div>

        <!-- Deck 2 -->
        <div>
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div><strong>DECK 2</strong><div class="small">YouTube or MP3</div></div>
            <div class="tag" id="tag-deck2">YT</div>
          </div>
          <div class="player-area" id="player-area-2">
            <iframe id="youtube-player2" src="https://www.youtube.com/embed?enablejsapi=1&playsinline=1&disablekb=1" allow="autoplay"></iframe>

            <div class="deck-audio-ui hidden" id="deck-audio-ui-2">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <div id="deck2-title" class="small">Local MP3</div>
                <div class="small" id="deck2-duration">0:00</div>
              </div>
              <div style="display:flex;gap:8px;align-items:center">
                <button id="deck2-playbtn">‚ñ∂</button>
                <input id="deck2-seek" type="range" min="0" max="100" value="0" style="flex:1">
                <input id="deck2-volume" type="range" min="0" max="100" value="80" style="width:120px">
              </div>
              <div style="display:flex;justify-content:space-between;align-items:center">
                <div class="small" id="deck2-current">0:00</div>
                <div style="display:flex;gap:6px"><button class="btn-ghost" id="deck2-lowcut">Low-cut</button></div>
              </div>
            </div>

            <div style="position:absolute;left:12px;right:12px;bottom:12px;display:flex;justify-content:space-between;align-items:center;gap:12px">
              <div style="flex:1;display:flex;flex-direction:column">
                <label class="small">BPM</label>
                <div class="bpm-row">
                  <input id="tempo2" class="tempo-slider" type="range" min="60" max="180" step="1" value="120">
                  <div id="tempo2-value" class="bpm-value">120</div>
                </div>
              </div>
              <div style="display:flex;flex-direction:column;align-items:flex-end">
                <div class="small muted">Deck 2</div>
                <div style="display:flex;gap:8px;margin-top:6px">
                  <button class="btn-ghost" id="reset-bpm-2">Reset BPM</button>
                </div>
              </div>
            </div>

            <div id="custom-dropdown2" class="dropdown" role="listbox" aria-hidden="true"></div>
          </div>
        </div>
      </div>

      <!-- crossfade & balance -->
      <div style="margin-top:12px" class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Crossfade & Balance</strong><div class="small">Smooth crossfade between decks</div></div>
          <div style="display:flex;gap:8px;align-items:center">
            <label class="small">Duration <input id="crossfade-duration" type="number" value="5000" style="width:90px"></label>
            <label class="small"><input id="crossfade-respect-balance" type="checkbox" checked> Respect balance</label>
          </div>
        </div>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <input id="balance-slider" type="range" min="0" max="100" value="50" style="flex:1">
          <div class="small" id="volume-percentage">Center (0%)</div>
          <div style="display:flex;gap:6px">
            <button class="btn-ghost" id="fade-a-b">A‚ÜíB</button>
            <button class="btn-ghost" id="fade-b-a">B‚ÜíA</button>
            <button class="btn-ghost" id="sync-btn">Sync</button>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Footer tabs -->
  <div class="footer-tabs">
    <button class="btn-ghost" id="tab-decks-btn">üéõ Decks</button>
    <button class="btn-ghost" id="open-history-btn">üéµ History</button>
    <button class="btn-ghost" id="open-mp3s-btn">üíΩ MP3s</button>
    <button class="btn-ghost" id="play-last-btn">‚èÆ Play Last</button>
  </div>

  <!-- Hidden audio elements for local MP3 playback -->
  <audio id="audio-deck1" crossorigin="anonymous"></audio>
  <audio id="audio-deck2" crossorigin="anonymous"></audio>

  <!-- History Modal (YouTube only) -->
  <div id="history-modal" class="modal" aria-hidden="true">
    <div class="card panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div><strong>History ‚Äî YouTube only</strong><div class="small">Only YouTube tracks are stored in History</div></div>
        <div style="display:flex;gap:8px">
          <button class="btn-ghost" id="history-backup">Backup</button>
          <input id="restore-input" type="file" style="display:none">
          <button class="btn-ghost" id="history-restore">Restore</button>
          <button class="close-x" id="close-history">Close ‚úï</button>
        </div>
      </div>

      <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center">
        <select id="category-filter-modal" style="min-width:180px"></select>
        <input id="history-search-modal" placeholder="Search history" style="flex:1">
        <input id="new-category-input-modal" placeholder="New category" style="width:220px">
        <button class="btn-ghost" id="add-category-modal">Add</button>
      </div>

      <div id="history-list-modal" class="list" tabindex="0"></div>
    </div>
  </div>

  <!-- MP3 Modal -->
  <div id="mp3-modal" class="modal" aria-hidden="true">
    <div class="card panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div><strong>Local MP3s</strong><div class="small">Saved in browser (IndexedDB)</div></div>
        <div style="display:flex;gap:8px">
          <button class="btn-ghost" id="mp3-refresh">Refresh</button>
          <button class="btn-ghost" id="mp3-clear">Delete All</button>
          <button class="close-x" id="close-mp3">Close ‚úï</button>
        </div>
      </div>

      <div id="mp3-list-modal" class="list" tabindex="0"></div>
    </div>
  </div>

  <!-- Notes & Chatbot -->
  <div id="notes-modal" class="modal" aria-hidden="true">
    <div class="card panel" style="max-width:600px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Notes</strong>
        <button class="close-x" id="close-notes">Close</button>
      </div>
      <textarea id="notes-textarea" style="width:100%;height:220px;margin-top:8px;background:#041019;color:#eaf2fb;padding:8px;border-radius:8px"></textarea>
      <div style="text-align:right;margin-top:8px"><button id="save-notes-btn">Save</button></div>
    </div>
  </div>

  <div id="chatbot-modal" class="modal" aria-hidden="true">
    <div class="card panel" style="max-width:600px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>AI Suggester</strong>
        <button class="close-x" id="close-chat">Close</button>
      </div>
      <div id="chat-messages" style="height:220px;overflow:auto;background:#021219;padding:8px;border-radius:8px;margin-top:8px"></div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <input id="chat-input" placeholder="Suggest songs..." style="flex:1">
        <button id="chat-send-btn">Suggest</button>
      </div>
    </div>
  </div>

<script>
/* =========================
   Robust initializations
   ========================= */

(function(){
  // Firebase config unchanged
  const firebaseConfig = {
    apiKey: "AIzaSyBPc51z-pGrtKwtB5dKTMPei-fVRg4ePME",
    authDomain: "pagdi-6f8ce.firebaseapp.com",
    databaseURL: "https://pagdi-6f8ce-default-rtdb.firebaseio.com",
    projectId: "pagdi-6f8ce",
    storageBucket: "pagdi-6f8ce.appspot.com",
    messagingSenderId: "746289566527",
    appId: "1:746289566527:web:4c32c4fec73bb7e898798a",
    measurementId: "G-CXW0QZRHFG"
  };
  firebase.initializeApp(firebaseConfig);
  const database = firebase.database();

  /* IndexedDB helpers (same, robust) */
  const DB_NAME = 'sammy-dj-db';
  const DB_STORE = 'mp3files';
  function openDb() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = e => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(DB_STORE)) {
          const store = db.createObjectStore(DB_STORE, { keyPath: 'id' });
          store.createIndex('created', 'created');
        }
      };
      req.onsuccess = e => resolve(e.target.result);
      req.onerror = e => reject(e.target.error);
    });
  }
  async function saveMp3File(name, blob) {
    const db = await openDb();
    return new Promise((res, rej) => {
      const tx = db.transaction(DB_STORE, 'readwrite');
      const store = tx.objectStore(DB_STORE);
      const id = 'mp3_' + Date.now() + '_' + Math.floor(Math.random()*10000);
      const rec = { id, name, blob, created: Date.now() };
      const req = store.add(rec);
      req.onsuccess = () => res(rec);
      req.onerror = (e) => rej(e.target.error);
    });
  }
  async function listMp3Files() {
    const db = await openDb();
    return new Promise((res, rej) => {
      const tx = db.transaction(DB_STORE, 'readonly');
      const store = tx.objectStore(DB_STORE);
      const arr = [];
      const cur = store.openCursor(null, 'prev');
      cur.onsuccess = e => {
        const c = e.target.result;
        if (c) { arr.push(c.value); c.continue(); }
        else res(arr);
      };
      cur.onerror = e => rej(e.target.error);
    });
  }
  async function getMp3File(id) {
    const db = await openDb();
    return new Promise((res, rej) => {
      const tx = db.transaction(DB_STORE, 'readonly');
      const store = tx.objectStore(DB_STORE);
      const req = store.get(id);
      req.onsuccess = e => res(e.target.result);
      req.onerror = e => rej(e.target.error);
    });
  }
  async function deleteMp3File(id) {
    const db = await openDb();
    return new Promise((res, rej) => {
      const tx = db.transaction(DB_STORE, 'readwrite');
      const store = tx.objectStore(DB_STORE);
      const req = store.delete(id);
      req.onsuccess = () => res();
      req.onerror = e => rej(e.target.error);
    });
  }
  async function clearAllLocalMp3s() {
    const db = await openDb();
    return new Promise((res, rej) => {
      const tx = db.transaction(DB_STORE, 'readwrite');
      const store = tx.objectStore(DB_STORE);
      const req = store.clear();
      req.onsuccess = () => { refreshLocalList(); alert('All local mp3s deleted'); res(); };
      req.onerror = e => rej(e.target.error);
    });
  }

  /* =========================
     YouTube API loader + safe stubs
     ========================= */
  let YTready = false;
  let player1 = null, player2 = null;
  function loadYouTubeAPI(){
    if (window.YT && window.YT.Player) { YTready = true; setupYTPlayers(); return; }
    if (!document.getElementById('yt-api')) {
      const s = document.createElement('script');
      s.id = 'yt-api';
      s.src = "https://www.youtube.com/iframe_api";
      document.head.appendChild(s);
    }
    // onYouTubeIframeAPIReady will be called by YT; define it once
    window.onYouTubeIframeAPIReady = function(){
      YTready = true;
      setupYTPlayers();
    };
  }
  function setupYTPlayers(){
    try {
      if (!player1) player1 = new YT.Player('youtube-player1', { events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange }});
      if (!player2) player2 = new YT.Player('youtube-player2', { events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange }});
    } catch(e){ console.warn('YT setup failed', e); }
  }
  function onPlayerReady(e){}
  function onPlayerStateChange(e){}

  /* =========================
     WebAudio & low-cut
     ========================= */
  const audioCtxs = {1:null,2:null};
  const mediaSources = {1:null,2:null};
  const lowCutFilters = {1:null,2:null};
  const lowCutState = {1:false,2:false};
  function initAudioContexts(){
    try {
      [1,2].forEach(deck => {
        try {
          const AudioCtxCtor = window.AudioContext || window.webkitAudioContext;
          if (!audioCtxs[deck]) audioCtxs[deck] = new AudioCtxCtor();
          const audioEl = document.getElementById(`audio-deck${deck}`);
          if (audioEl && !mediaSources[deck]) {
            try { mediaSources[deck] = audioCtxs[deck].createMediaElementSource(audioEl); } catch(e){ mediaSources[deck] = null; }
          }
          if (!lowCutFilters[deck]) {
            const filter = audioCtxs[deck].createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 120;
            filter.Q.value = 1;
            lowCutFilters[deck] = filter;
          }
          if (mediaSources[deck]) {
            try { mediaSources[deck].disconnect(); mediaSources[deck].connect(audioCtxs[deck].destination); } catch(e){}
          }
        } catch(e){ console.warn('initAudioContexts deck',deck,e); }
      });
    } catch(e){ console.warn('initAudioContexts failed', e); }
  }
  function applyLowCutConnection(deck, enable){
    const src = mediaSources[deck], filter = lowCutFilters[deck], ctx = audioCtxs[deck];
    if (!src || !filter || !ctx) return;
    try { src.disconnect(); } catch(e){}
    if (enable) { src.connect(filter); filter.connect(ctx.destination); } else { try { filter.disconnect(); } catch(e){} src.connect(ctx.destination); }
  }
  function toggleLowCut(deck){
    const audioEl = document.getElementById(`audio-deck${deck}`);
    const currentSrc = audioEl && (audioEl.src || '');
    const isLocal = currentSrc && (currentSrc.startsWith('blob:') || currentSrc.startsWith('data:') || (!currentSrc.includes('youtube.com') && !currentSrc.includes('googlevideo.com')));
    if (!isLocal) { alert('Low-cut filter works for local MP3 playback only.'); return; }
    lowCutState[deck] = !lowCutState[deck];
    applyLowCutConnection(deck, !!lowCutState[deck]);
    document.getElementById(`deck${deck}-lowcut`).textContent = lowCutState[deck] ? 'Low-cut ‚úì' : 'Low-cut';
  }

  /* =========================
     Deck wrapper: unifies YT & audio and resets BPM on load
     ========================= */
  function createDeckWrapper(deckNumber){
    const audioEl = document.getElementById(`audio-deck${deckNumber}`);
    let current = { type:null, id:null, title:'' };
    return {
      async loadSource(src){
        if (!src) return;
        resetDeckBpm(deckNumber); // reset BPM on every load
        if (src.type === 'youtube'){
          current = { type:'youtube', id:src.videoId, title: src.title || '' };
          // show iframe, hide audio UI
          showDeckSource(deckNumber,'youtube');
          if (YTready){
            const player = deckNumber===1 ? player1 : player2;
            try { if (player && typeof player.loadVideoById === 'function') player.loadVideoById(src.videoId); } catch(e){ console.warn(e); }
          } else {
            // fallback: set iframe src (works even if API not ready)
            const iframe = document.getElementById(`youtube-player${deckNumber}`);
            if (iframe) iframe.src = `https://www.youtube.com/embed/${encodeURIComponent(src.videoId)}?enablejsapi=1&playsinline=1&autoplay=1`;
          }
        } else if (src.type === 'audio'){
          try { if (audioEl._objectUrl) { URL.revokeObjectURL(audioEl._objectUrl); audioEl._objectUrl = null; } } catch(e){}
          audioEl.src = src.url;
          audioEl._objectUrl = src.url;
          audioEl.currentTime = 0;
          audioEl.playbackRate = typeof src.playbackRate === 'number' ? src.playbackRate : 1;
          current = { type:'audio', id: src.id || src.url, title: src.name || 'Local MP3' };
          try { if (audioCtxs[deckNumber] && audioCtxs[deckNumber].state === 'suspended') audioCtxs[deckNumber].resume(); } catch(e){}
          applyLowCutConnection(deckNumber, !!lowCutState[deckNumber]);
          showDeckSource(deckNumber,'audio');
          bindDeckAudioUI(deckNumber);
        }
        updateDeckTitleUI(deckNumber, current.title || 'None');
      },
      play(){ if (current.type === 'youtube'){ try{ const p = deckNumber===1?player1:player2; if (p && typeof p.playVideo==='function') p.playVideo(); }catch(e){} } else { try{ audioEl.play(); }catch(e){} } },
      pause(){ if (current.type === 'youtube'){ try{ const p = deckNumber===1?player1:player2; if (p && typeof p.pauseVideo==='function') p.pauseVideo(); }catch(e){} } else try{ audioEl.pause(); }catch(e){} },
      setVolume(v100){ const v = Math.max(0,Math.min(100,Math.round(v100))); if (current.type==='youtube'){ try{ const p = deckNumber===1?player1:player2; if (p && typeof p.setVolume==='function') p.setVolume(v); }catch(e){} } else try{ audioEl.volume = Math.max(0,Math.min(1,v/100)); }catch(e){} },
      getVolume(){ if (current.type==='youtube'){ try{ const p = deckNumber===1?player1:player2; if (p && typeof p.getVolume==='function') return p.getVolume(); }catch(e){} return 50; } else try{ return Math.round((audioEl.volume||0)*100); }catch(e){return 50;} },
      setPlaybackRate(r){ if (!isFinite(r)) return; try{ if (current.type==='youtube'){ const p = deckNumber===1?player1:player2; if (p && typeof p.setPlaybackRate==='function') p.setPlaybackRate(r); } else audioEl.playbackRate = r; }catch(e){console.warn(e);} },
      seekTo(seconds, allow=true){ if (current.type==='youtube'){ try{ const p = deckNumber===1?player1:player2; if (p && typeof p.seekTo==='function') p.seekTo(seconds, allow); }catch(e){} } else try{ audioEl.currentTime = seconds; }catch(e){} },
      getPlayerState(){ if (current.type==='youtube'){ try{ const p = deckNumber===1?player1:player2; if (p && typeof p.getPlayerState==='function') return p.getPlayerState(); }catch(e){} return -1; } else { const paused = audioEl.paused; return paused?2:1; } },
      getCurrentTime(){ if (current.type==='youtube'){ try{ const p = deckNumber===1?player1:player2; if (p && typeof p.getCurrentTime==='function') return p.getCurrentTime(); }catch(e){} return 0; } else return audioEl.currentTime || 0; }
    };
  }

  const deckWrappers = { 1:createDeckWrapper(1), 2:createDeckWrapper(2) };

  /* =========================
     UI helpers (deck audio controls)
     ========================= */
  function bindDeckAudioUI(deck){
    const audio = document.getElementById(`audio-deck${deck}`);
    const playBtn = document.getElementById(`deck${deck}-playbtn`);
    const seek = document.getElementById(`deck${deck}-seek`);
    const vol = document.getElementById(`deck${deck}-volume`);
    const cur = document.getElementById(`deck${deck}-current`);
    const dur = document.getElementById(`deck${deck}-duration`);
    if (!audio) return;
    vol.value = Math.round((audio.volume||0.8)*100);
    audio.onloadedmetadata = ()=> { dur.textContent = formatTime(audio.duration || 0); };
    audio.ontimeupdate = ()=> { const c = audio.currentTime || 0; const d = audio.duration || 0; cur.textContent = formatTime(c); if (d) seek.value = Math.round((c/d)*100); };
    audio.onplay = ()=> playBtn.textContent = '‚è∏';
    audio.onpause = ()=> playBtn.textContent = '‚ñ∂';
    audio.onended = ()=> { playBtn.textContent='‚ñ∂'; };
    playBtn.onclick = ()=> { if (audio.paused) audio.play().catch(()=>{}); else audio.pause(); };
    seek.oninput = (e)=> { if (!audio.duration) return; const pct = parseFloat(e.target.value); audio.currentTime = (pct/100)*audio.duration; };
    vol.oninput = (e)=> { audio.volume = Math.max(0,Math.min(1,parseInt(e.target.value,10)/100)); };
  }

  function deckTogglePlay(deck){ const a = document.getElementById(`audio-deck${deck}`); if (!a) return; a.paused ? a.play().catch(()=>{}) : a.pause(); }
  function deckSeekFromUI(deck,pct){ const a = document.getElementById(`audio-deck${deck}`); if (!a || !a.duration) return; a.currentTime = (pct/100)*a.duration; }
  function deckSetVolume(deck,v){ const a = document.getElementById(`audio-deck${deck}`); if (!a) return; a.volume = Math.max(0,Math.min(1,v/100)); }

  function updateDeckTitleUI(deck,title){ const el = document.getElementById(`deck${deck}-title`); if (el) el.textContent = title || 'None'; }

  function showDeckSource(deck,type){
    const iframe = document.getElementById(`youtube-player${deck}`);
    const audioUI = document.getElementById(`deck-audio-ui-${deck}`);
    const tag = document.getElementById(`tag-deck${deck}`);
    if (type === 'audio'){ if (iframe) iframe.style.display = 'none'; if (audioUI) audioUI.classList.remove('hidden'); if (tag) tag.textContent='MP3'; } else { if (iframe) iframe.style.display=''; if (audioUI) audioUI.classList.add('hidden'); if (tag) tag.textContent='YT'; }
  }

  /* =========================
     MP3 file input handling & lists
     ========================= */
  const mp3Input = document.getElementById('mp3-input');
  document.getElementById('add-mp3-btn').addEventListener('click', ()=> mp3Input.click());
  mp3Input.addEventListener('change', async (ev) => {
    const f = ev.target.files && ev.target.files[0];
    if (!f) return;
    const valid = (f.type && f.type.startsWith('audio/')) || f.name.toLowerCase().endsWith('.mp3');
    if (!valid) { alert('Please select an audio file (mp3).'); ev.target.value=''; return; }
    try {
      const blob = f.slice ? f.slice(0,f.size,f.type) : f;
      await saveMp3File(f.name, blob);
      await refreshLocalList();
      alert('Saved "'+f.name+'". It will persist in your browser.');
    } catch (e) { console.error(e); alert('Saving failed'); }
    ev.target.value = '';
  });

  async function refreshLocalList(){
    const container = document.getElementById('mp3-list-modal');
    if (!container) return;
    container.innerHTML = '<div class="muted">Loading‚Ä¶</div>';
    try {
      const files = await listMp3Files();
      container.innerHTML = '';
      if (!files || files.length===0) { container.innerHTML = '<div class="muted">No saved MP3s</div>'; return; }
      files.forEach(rec => {
        const row = document.createElement('div'); row.className='history-row';
        const left = document.createElement('div'); left.style.flex='1'; left.innerHTML = `<strong>${escapeHtml(rec.name)}</strong><div class="muted" style="font-size:12px">Saved: ${new Date(rec.created).toLocaleString()}</div>`;
        const right = document.createElement('div'); right.style.display='flex'; right.style.gap='6px';
        const play = document.createElement('button'); play.textContent='Play'; play.onclick = ()=> mp3PlayPreview(rec.id);
        const d1 = document.createElement('button'); d1.textContent='‚Üí Deck 1'; d1.className='btn-ghost'; d1.onclick = ()=> playLocalOnDeck(rec.id,1);
        const d2 = document.createElement('button'); d2.textContent='‚Üí Deck 2'; d2.className='btn-ghost'; d2.onclick = ()=> playLocalOnDeck(rec.id,2);
        const del = document.createElement('button'); del.textContent='Delete'; del.className='btn-ghost'; del.onclick = async ()=> { if (!confirm('Delete "'+rec.name+'"?')) return; await deleteMp3File(rec.id); refreshLocalList(); };
        right.appendChild(play); right.appendChild(d1); right.appendChild(d2); right.appendChild(del);
        row.appendChild(left); row.appendChild(right); container.appendChild(row);
      });
    } catch (e) { console.error(e); container.innerHTML = '<div class="muted">Failed to load</div>'; }
  }

  async function mp3PlayPreview(id){
    try {
      const rec = await getMp3File(id);
      if (!rec) return alert('File not found');
      const url = URL.createObjectURL(rec.blob);
      await deckWrappers[1].loadSource({ type:'audio', url, id:rec.id, name:rec.name });
      const bal = parseInt(document.getElementById('balance-slider').value || 50,10);
      deckWrappers[1].setVolume(100 - bal);
      deckWrappers[1].play();
      updateDeckTitleUI(1, rec.name);
    } catch (e){ console.error(e); alert('Playback failed'); }
  }

  async function playLocalOnDeck(id, deckNumber){
    try {
      const rec = await getMp3File(id);
      if (!rec) return alert('File not found');
      const url = URL.createObjectURL(rec.blob);
      await deckWrappers[deckNumber].loadSource({ type:'audio', url, id:rec.id, name:rec.name });
      const bal = parseInt(document.getElementById('balance-slider').value || 50,10);
      deckWrappers[1].setVolume(100 - bal); deckWrappers[2].setVolume(bal);
      deckWrappers[deckNumber].play();
      updateDeckTitleUI(deckNumber, rec.name);
    } catch (e){ console.error(e); alert('Failed to play local mp3'); }
  }

  /* =========================
     YouTube Search & dropdown handling (robust)
     ========================= */
  const API_KEYS = ['13452c8109msh7750057c5193b47p1c47c0jsn5d53a80bb998','d85300e47amsh5ad671c2832cec6p1b7953jsnab9c3a237b6e'];
  const searchState = { deck1:{query:'',nextToken:null,apiKeyIndex:0,loading:false}, deck2:{query:'',nextToken:null,apiKeyIndex:0,loading:false} };

  function escapeHtml(str){ if (!str && str!==0) return ''; return String(str).replace(/[&<>"'`=\/]/g,s=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','/':'&#x2F;','`':'&#x60;'})[s]); }
  function extractContinuation(data){
    if (!data) return null;
    const tryPaths = ['continuation','next','continuationToken','cursor','token','nextToken','cursorToken'];
    for (const p of tryPaths) if (data[p]) return data[p];
    if (data.continuations && Array.isArray(data.continuations) && data.continuations[0]) {
      return data.continuations[0].token || data.continuations[0].cursor || data.continuations[0].next || null;
    }
    for (const k of Object.keys(data || {})){
      const v = data[k];
      if (v && typeof v === 'object'){
        for (const p of tryPaths) if (v[p]) return v[p];
      }
    }
    return null;
  }

  function adaptDropdownToPlayer(deck){
    try {
      const playerArea = document.getElementById(`player-area-${deck}`);
      const dropdown = document.getElementById(`custom-dropdown${deck}`);
      if (!playerArea || !dropdown) return;
      const rect = playerArea.getBoundingClientRect();
      const widthPx = Math.max(220, rect.width - 24);
      dropdown.style.width = widthPx + 'px';
      dropdown.style.left = '12px';
      dropdown.style.top = '10px';
    } catch(e){ console.warn(e); }
  }

  function ensureDropdownScrollLoad(deck){
    const dropdown = document.getElementById(`custom-dropdown${deck}`);
    if (!dropdown) return;
    if (dropdown.dataset.scrollInit) return;
    dropdown.dataset.scrollInit = '1';
    dropdown.addEventListener('scroll', () => {
      const threshold = 80;
      if (dropdown.scrollTop + dropdown.clientHeight >= dropdown.scrollHeight - threshold) loadMoreSearch(deck === 1 ? 'deck1' : 'deck2').catch(()=>{});
    });
  }

  async function searchYouTubeForDeck(deck, apiKeyIndex = 0, autoLoad=false, songInfo=null){
    const deckKey = deck === 'deck1' ? 'deck1' : 'deck2';
    const inputId = deckKey === 'deck1' ? 'search-deck1' : 'search-deck2';
    const queryEl = document.getElementById(inputId);
    const query = (queryEl && queryEl.value) ? queryEl.value.trim() : '';
    if (!query) { alert('Please enter a search term.'); return; }

    searchState[deckKey].query = query;
    searchState[deckKey].nextToken = null;
    searchState[deckKey].apiKeyIndex = apiKeyIndex;
    searchState[deckKey].loading = true;

    const url = `https://youtube-search-and-download.p.rapidapi.com/search?query=${encodeURIComponent(query)}&type=all`;
    const headers = { 'x-rapidapi-host': 'youtube-search-and-download.p.rapidapi.com','x-rapidapi-key': API_KEYS[apiKeyIndex] };

    try {
      const resp = await fetch(url, { method:'GET', headers });
      if (resp.status === 429 && apiKeyIndex < API_KEYS.length - 1) return searchYouTubeForDeck(deck, apiKeyIndex + 1, autoLoad, songInfo);
      if (!resp.ok) throw new Error('HTTP ' + resp.status);
      const data = await resp.json();
      const dropdown = document.getElementById(`custom-dropdown${deck === 'deck1' ? 1 : 2}`);
      if (!dropdown) return;
      dropdown.innerHTML = '';
      adaptDropdownToPlayer(deck === 'deck1' ? 1 : 2);
      dropdown.style.display = 'none';
      dropdown.setAttribute('aria-hidden','true');

      let items = [];
      if (Array.isArray(data.contents)) items = data.contents;
      else if (Array.isArray(data.items)) items = data.items;
      else if (Array.isArray(data.result)) items = data.result;
      else {
        for (const k of Object.keys(data || {})) if (Array.isArray(data[k]) && data[k].length) { items = data[k]; break; }
      }

      const cont = extractContinuation(data);
      searchState[deckKey].nextToken = cont || null;
      searchState[deckKey].apiKeyIndex = apiKeyIndex;
      searchState[deckKey].loading = false;

      let foundAny = false;
      (items || []).slice(0,60).forEach(entry => {
        if (entry && entry.video) {
          foundAny = true;
          const v = entry.video;
          const videoId = v.videoId || v.id || (v.video && v.video.videoId) || '';
          const title = v.title || v.videoTitle || 'Untitled';
          const thumb = (v.thumbnails && v.thumbnails[0] && v.thumbnails[0].url) || v.thumbnail || 'https://via.placeholder.com/50';
          const duration = v.duration || v.length || v.durationText || '';
          const dropdownItem = document.createElement('div');
          dropdownItem.className = 'item';
          dropdownItem.addEventListener('click', (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            const playerWrapper = deck === 'deck1' ? deckWrappers[1] : deckWrappers[2];
            try {
              playerWrapper.loadSource({ type:'youtube', videoId, title });
              addNewTrackToHistory(title, videoId, 'Uncategorized');
              dropdown.style.display = 'none';
              dropdown.setAttribute('aria-hidden','true');
            } catch (e) { console.error(e); }
          });
          dropdownItem.innerHTML = `<img src="${thumb}" alt="${escapeHtml(title)} thumbnail" style="width:56px;height:40px;object-fit:cover;border-radius:6px;margin-right:8px"><div style="flex:1"><div style="font-size:13px">${escapeHtml(title)}</div><div class="muted">${duration ? duration : 'Video'}</div></div>`;
          dropdown.appendChild(dropdownItem);
        } else if (entry && entry.channel) {
          const c = entry.channel;
          const channelId = c.channelId || c.id || '';
          const title = c.title || c.name || 'Channel';
          const thumb = (c.thumbnails && c.thumbnails[0] && c.thumbnails[0].url) || c.avatar || 'https://via.placeholder.com/50';
          const dropdownItem = document.createElement('div');
          dropdownItem.className = 'item';
          // use addEventListener and stop propagation so player-area click doesn't close dropdown
          dropdownItem.addEventListener('click', (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            fetchChannelVideos(channelId, deck, apiKeyIndex);
          });
          dropdownItem.innerHTML = `<img src="${thumb}" style="width:56px;height:40px;object-fit:cover;border-radius:6px;margin-right:8px"><div style="flex:1"><div style="font-size:13px">${escapeHtml(title)}</div><div class="muted">Channel</div></div>`;
          dropdown.appendChild(dropdownItem);
        }
      });

      ensureDropdownScrollLoad(deck === 'deck1' ? 1 : 2);

      if (!foundAny && (items || []).length === 0) dropdown.innerHTML = '<div class="muted">No results</div>';
      else { dropdown.style.display = 'block'; dropdown.setAttribute('aria-hidden','false'); }

      if (autoLoad && songInfo && dropdown.firstChild) dropdown.firstChild.click();
    } catch (err) {
      console.error('Search error', err);
      searchState[deckKey].loading = false;
      alert('Error fetching search results. See console.');
    }
  }

  async function loadMoreSearch(deck){
    const deckKey = deck === 'deck1' ? 'deck1' : 'deck2';
    const state = searchState[deckKey];
    if (!state || !state.query || state.loading || !state.nextToken) return;
    state.loading = true;
    const dropdown = document.getElementById(`custom-dropdown${deck === 'deck1' ? 1 : 2}`);
    if (!dropdown) { state.loading=false; return; }
    let loader = document.createElement('div'); loader.className='muted'; loader.textContent='Loading more...'; dropdown.appendChild(loader);
    const apiIndex = state.apiKeyIndex || 0;
    const attempts = [
      `https://youtube-search-and-download.p.rapidapi.com/search?query=${encodeURIComponent(state.query)}&type=all&next=${encodeURIComponent(state.nextToken)}`,
      `https://youtube-search-and-download.p.rapidapi.com/search?query=${encodeURIComponent(state.query)}&type=all&cursor=${encodeURIComponent(state.nextToken)}`,
      `https://youtube-search-and-download.p.rapidapi.com/next?cursor=${encodeURIComponent(state.nextToken)}`,
      `https://youtube-search-and-download.p.rapidapi.com/search?query=${encodeURIComponent(state.query)}&type=video&token=${encodeURIComponent(state.nextToken)}`
    ];
    let success=false;
    for (let u of attempts){
      try {
        const resp = await fetch(u, { method:'GET', headers:{ 'x-rapidapi-host':'youtube-search-and-download.p.rapidapi.com','x-rapidapi-key':API_KEYS[apiIndex] } });
        if (resp.status === 429) { const nextKeyIndex = (apiIndex+1)%API_KEYS.length; state.apiKeyIndex = nextKeyIndex; state.loading=false; loader.remove(); return loadMoreSearch(deck); }
        if (!resp.ok) throw new Error('HTTP '+resp.status);
        const data = await resp.json();
        let items = [];
        if (Array.isArray(data.contents)) items = data.contents;
        else if (Array.isArray(data.items)) items = data.items;
        else if (Array.isArray(data.videos)) items = data.videos;
        else for (const k of Object.keys(data || {})) if (Array.isArray(data[k]) && data[k].length) { items = data[k]; break; }
        const newCont = extractContinuation(data);
        state.nextToken = newCont || null;
        (items || []).slice(0,60).forEach(entry => {
          if (entry && entry.video) {
            const v = entry.video;
            const videoId = v.videoId || v.id || (v.video && v.video.videoId) || '';
            const title = v.title || v.videoTitle || 'Untitled';
            const thumb = (v.thumbnails && v.thumbnails[0] && v.thumbnails[0].url) || v.thumbnail || 'https://via.placeholder.com/50';
            const duration = v.duration || v.length || v.durationText || '';
            const dropdownItem = document.createElement('div');
            dropdownItem.className = 'item';
            dropdownItem.addEventListener('click', (ev) => {
              ev.preventDefault();
              ev.stopPropagation();
              try {
                const playerWrapper = deck === 'deck1' ? deckWrappers[1] : deckWrappers[2];
                playerWrapper.loadSource({ type:'youtube', videoId, title });
                addNewTrackToHistory(title, videoId, 'Uncategorized');
                dropdown.style.display = 'none';
                dropdown.setAttribute('aria-hidden','true');
              } catch(e){ console.error(e); }
            });
            dropdownItem.innerHTML = `<img src="${thumb}" style="width:56px;height:40px;object-fit:cover;border-radius:6px;margin-right:8px"><div style="flex:1"><div style="font-size:13px">${escapeHtml(title)}</div><div class="muted">${duration ? duration : 'Video'}</div></div>`;
            dropdown.appendChild(dropdownItem);
          }
        });
        state.loading=false; loader.remove(); success=true; break;
      } catch (err){ console.warn('loadMore failed', err); }
    }
    if (!success){ state.loading=false; loader.remove(); const msg=document.createElement('div'); msg.className='muted'; msg.textContent='No further results.'; dropdown.appendChild(msg); }
  }

  async function fetchChannelVideos(channelId, deck, apiKeyIndex=0){
    if (!channelId) { alert('Channel ID missing'); return; }
    // normalize deck: accept 'deck1'/'deck2' or numeric 1/2
    const deckNum = (function(d){
      if (d === 1 || d === '1' || d === 'deck1') return 1;
      if (d === 2 || d === '2' || d === 'deck2') return 2;
      return 1;
    })(deck);
    const dropdown = document.getElementById(`custom-dropdown${deckNum}`);
    if (!dropdown) return;
    dropdown.innerHTML = '<div class="muted">Loading channel videos...</div>';
    dropdown.style.display = 'block';
    dropdown.setAttribute('aria-hidden','false');
    adaptDropdownToPlayer(deckNum);
    const urlsToTry = [
      `https://youtube-search-and-download.p.rapidapi.com/channel?id=${encodeURIComponent(channelId)}`,
      `https://youtube-search-and-download.p.rapidapi.com/channel/videos?id=${encodeURIComponent(channelId)}`,
      `https://youtube-search-and-download.p.rapidapi.com/search?query=${encodeURIComponent('channel:' + channelId)}&type=video`
    ];
    let success=false;
    for (let i=0;i<urlsToTry.length && !success;i++){
      try {
        const url = urlsToTry[i];
        const resp = await fetch(url, { method:'GET', headers:{ 'x-rapidapi-host':'youtube-search-and-download.p.rapidapi.com','x-rapidapi-key':API_KEYS[apiKeyIndex] }});
        if (resp.status === 429 && apiKeyIndex < API_KEYS.length - 1) return fetchChannelVideos(channelId, deck, apiKeyIndex+1);
        if (!resp.ok) throw new Error('HTTP '+resp.status);
        const data = await resp.json();
        let videos=[];
        if (Array.isArray(data.contents)) {
          const flat=[]; data.contents.forEach(c => { if (c && c.videos && Array.isArray(c.videos)) flat.push(...c.videos); else if (c && c.video) flat.push(c.video); else if (Array.isArray(c)) flat.push(...c); });
          videos = flat.length ? flat : data.contents;
        } else if (Array.isArray(data.videos)) videos = data.videos;
        else if (Array.isArray(data.items)) videos = data.items;
        else for (const k of Object.keys(data||{})) if (Array.isArray(data[k]) && data[k].length && (data[k][0].videoId||data[k][0].id||data[k][0].title)) { videos = data[k]; break; }
        dropdown.innerHTML = '';
        const back = document.createElement('div'); back.className='muted'; back.style.fontWeight='700'; back.textContent='‚Üê Back'; back.onclick = ()=> dropdown.style.display='none'; dropdown.appendChild(back);
        if (!videos || !videos.length) { const nores=document.createElement('div'); nores.className='muted'; nores.textContent='No videos found'; dropdown.appendChild(nores); success=true; break; }
        videos.slice(0,50).forEach(v => {
          const videoId = v.videoId || (v.id && (v.id.videoId || v.id)) || v.video_id || v.video?.videoId || '';
          const title = v.title || v.name || v.videoTitle || (v.snippet && v.snippet.title) || 'Untitled';
          const thumb = (v.thumbnails && v.thumbnails[0] && v.thumbnails[0].url) || (v.thumbnail && v.thumbnail.url) || 'https://via.placeholder.com/50';
          const duration = v.duration || v.length || (v.snippet && v.snippet.lengthText && v.snippet.lengthText.simpleText) || '';
          const item = document.createElement('div'); item.className='item';
          item.innerHTML = `<img src="${thumb}" style="width:56px;height:40px;object-fit:cover;border-radius:6px;margin-right:8px"><div style="flex:1"><div style="font-size:13px">${escapeHtml(title)}</div><div class="muted">${duration || 'Video'}</div></div>`;
          item.addEventListener('click', (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            const playerWrapper = deckNum===1?deckWrappers[1]:deckWrappers[2];
            try { playerWrapper.loadSource({ type:'youtube', videoId, title }); addNewTrackToHistory(title, videoId, 'Uncategorized'); dropdown.style.display='none'; } catch(e){ console.error(e); }
          });
          dropdown.appendChild(item);
        });
        success=true;
      } catch (err) { console.warn('channel fetch failed', err); if (err.message && err.message.includes('429') && apiKeyIndex < API_KEYS.length - 1) return fetchChannelVideos(channelId, deck, apiKeyIndex+1); }
    }
    if (!success){ dropdown.innerHTML=''; const errElem=document.createElement('div'); errElem.className='muted'; errElem.textContent='Failed to fetch channel videos.'; dropdown.appendChild(errElem); }
  }

  /* =========================
     History (firebase) & categories
     ========================= */
  let djCategories = [];
  function createHistoryRow(title, videoId, category, key){
    const tr = document.createElement('div'); tr.className='history-row';
    tr.setAttribute('data-video-id', videoId||'');
    tr.setAttribute('data-firebase-key', key||'');
    tr.setAttribute('data-category', category||'Uncategorized');
    const left = document.createElement('div'); left.style.flex='1'; left.innerHTML = `<strong>${escapeHtml(title)}</strong><div class="muted" style="font-size:12px">${escapeHtml(category)}</div>`;
    const right = document.createElement('div'); right.style.display='flex'; right.style.gap='8px';
    const btn1 = document.createElement('button'); btn1.textContent='Play ‚Üí D1'; btn1.onclick = ()=> { deckWrappers[1].loadSource({ type:'youtube', videoId }); updateDeckTitleUI(1, title); };
    const btn2 = document.createElement('button'); btn2.textContent='Play ‚Üí D2'; btn2.onclick = ()=> { deckWrappers[2].loadSource({ type:'youtube', videoId }); updateDeckTitleUI(2, title); };
    const sel = document.createElement('select');
    function buildOptions(){
      sel.innerHTML = '';
      const o0=document.createElement('option'); o0.value='Uncategorized'; o0.textContent='Uncategorized'; sel.appendChild(o0);
      (djCategories||[]).forEach(c => { const o=document.createElement('option'); o.value=c; o.textContent=c; sel.appendChild(o); });
      const oNew=document.createElement('option'); oNew.value='__new__'; oNew.textContent='+ Add New Category'; sel.appendChild(oNew);
      sel.value = category || 'Uncategorized';
    }
    buildOptions();
    sel.onchange = async (e) => {
      let val = e.target.value;
      if (val === '__new__'){
        const newName = prompt('Enter new category name:');
        if (!newName||!newName.trim()){ sel.value = category || 'Uncategorized'; return; }
        val = newName.trim();
        if (!djCategories.includes(val)){ djCategories.push(val); await database.ref('djCategories').set(djCategories); }
        sel.value = val;
      }
      const key = tr.getAttribute('data-firebase-key');
      if (key) database.ref(`playedHistory/${key}/category`).set(val).then(()=> tr.setAttribute('data-category',val)).catch(e=>console.error(e));
      left.querySelector('.muted').textContent = val;
      filterHistoryModal();
    };
    const del = document.createElement('button'); del.textContent='Delete'; del.className='btn-ghost'; del.onclick = ()=> { const key = tr.getAttribute('data-firebase-key'); if (key) database.ref('playedHistory').child(key).remove(); };
    right.appendChild(btn1); right.appendChild(btn2); right.appendChild(sel); right.appendChild(del);
    tr._buildSelect = buildOptions;
    tr._select = sel;
    tr.appendChild(left); tr.appendChild(right);
    return tr;
  }

  function addNewTrackToHistory(title, videoId, category='Uncategorized'){ if (!videoId) return; database.ref('playedHistory').push({ title, videoId, category, timestamp:Date.now() }); }

  function refreshAllCategorySelects(){
    document.querySelectorAll('.history-row').forEach(row => { if (row._buildSelect) row._buildSelect(); });
    populateCategoryFilter();
  }

  function populateCategoryFilter(){
    const s = document.getElementById('category-filter-modal');
    if (!s) return;
    s.innerHTML = '<option value="">All</option>';
    (djCategories||[]).forEach(cat => { const o=document.createElement('option'); o.value=cat; o.textContent=cat; s.appendChild(o); });
  }

  function filterHistoryModal(){
    const q = (document.getElementById('history-search-modal')?.value||'').toLowerCase();
    const sel = (document.getElementById('category-filter-modal')?.value||'');
    const wrapper = document.getElementById('history-list-modal'); if (!wrapper) return;
    wrapper.querySelectorAll('.history-row').forEach(row=>{
      const title = (row.querySelector('strong')?.textContent||'').toLowerCase();
      const select = row.querySelector('select');
      const cat = select ? select.value : (row.querySelector('.muted')?.textContent || '');
      const okText = q ? title.includes(q) : true;
      const okCat = sel ? (cat === sel) : true;
      row.style.display = (okText && okCat) ? '' : 'none';
    });
  }

  // Firebase listeners
  function initListeners(){
    database.ref('playedHistory').on('value', snapshot => {
      const data = snapshot.val() || {};
      const tracks = Object.entries(data).map(([key,track]) => ({...track, key})).sort((a,b)=> b.timestamp - a.timestamp);
      const tbody = document.getElementById('history-list-modal');
      if (tbody) tbody.innerHTML = '';
      tracks.forEach(track => { if (track.videoId && String(track.videoId).trim() !== '') {
        const r = createHistoryRow(track.title, track.videoId, track.category || 'Uncategorized', track.key);
        tbody.appendChild(r);
      }});
      refreshAllCategorySelects();
    });
    database.ref('djCategories').on('value', snapshot => { djCategories = snapshot.val() || []; populateCategoryFilter(); refreshAllCategorySelects(); });
    database.ref('djNotes').on('value', snapshot => { const notes = snapshot.val() || ''; const el = document.getElementById('notes-textarea'); if (el) el.value = notes; });
  }

  function backupHistory(){
    database.ref('playedHistory').once('value').then(snapshot=>{
      const historyData = snapshot.val()||{};
      const tracks = Object.values(historyData);
      const categoriesData = djCategories;
      const backupData = { history: tracks, categories: categoriesData };
      const blob = new Blob([JSON.stringify(backupData,null,2)], {type:'application/json'});
      const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download='played-history.json'; link.click();
    });
  }
  function restoreHistoryFromFile(file){
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e){
      try {
        let historyData = JSON.parse(e.target.result);
        if (historyData && historyData.history){
          database.ref('playedHistory').remove().then(()=> historyData.history.forEach(track=> database.ref('playedHistory').push({ title: track.title, videoId: track.videoId, category: track.category || 'Uncategorized', timestamp: track.timestamp || Date.now() })));
          if (historyData.categories) database.ref('djCategories').set(historyData.categories);
        } else if (Array.isArray(historyData)){
          database.ref('playedHistory').remove().then(()=> historyData.forEach(track=> database.ref('playedHistory').push({ title: track.title, videoId: track.videoId, category: track.category || 'Uncategorized', timestamp: track.timestamp || Date.now() })));
        } else alert('Invalid backup file');
      } catch (err){ console.error(err); alert('Failed to restore'); }
    };
    reader.readAsText(file);
  }

  /* =========================
     Balance & crossfade
     ========================= */
  function onBalanceChange(){
    const bal = parseInt(document.getElementById('balance-slider')?.value || 50,10);
    const side = bal===50 ? 'Center' : (bal<50 ? 'Deck 1' : 'Deck 2');
    const percentage = bal===50?0:(bal<50?(50-bal):(bal-50));
    const el = document.getElementById('volume-percentage');
    if (el) el.textContent = `${side} (${percentage}%)`;
    try { deckWrappers[1].setVolume(100 - bal); deckWrappers[2].setVolume(bal); } catch(e){}
  }

  function smoothCrossfade(fromDeck=1,toDeck=2,duration=5000,options={}) {
    const { stopSource=true, respectBalanceSlider=true } = options;
    const fromPlayer = deckWrappers[fromDeck], toPlayer = deckWrappers[toDeck];
    if (!fromPlayer || !toPlayer) return;
    let startVolFrom = fromPlayer.getVolume ? fromPlayer.getVolume() : 50;
    let targetMax = 100;
    if (respectBalanceSlider) { const bal = parseInt(document.getElementById('balance-slider')?.value || 50,10); targetMax = (toDeck===1?100-bal:bal); targetMax = Math.max(0,Math.min(100,targetMax)); }
    try { toPlayer.setVolume(0); toPlayer.play(); } catch(e){}
    fromPlayer.setVolume(startVolFrom);
    const startTime = performance.now();
    function step(now){
      const elapsed = now - startTime;
      const t = Math.max(0, Math.min(1, elapsed/Math.max(1,duration)));
      const gainFrom = Math.cos(t * Math.PI / 2);
      const gainTo = Math.sin(t * Math.PI / 2);
      const volFrom = startVolFrom * gainFrom;
      const volTo = targetMax * gainTo;
      fromPlayer.setVolume(volFrom);
      toPlayer.setVolume(volTo);
      if (respectBalanceSlider){
        let sliderVal;
        if (toDeck===2) sliderVal = Math.round(volTo); else sliderVal = Math.round(100-volTo);
        sliderVal = Math.max(0,Math.min(100,sliderVal));
        document.getElementById('balance-slider').value = sliderVal;
        onBalanceChange();
      }
      if (t<1) requestAnimationFrame(step);
      else { fromPlayer.setVolume(0); toPlayer.setVolume(targetMax); if (stopSource) try{ fromPlayer.pause(); } catch(e){} }
    }
    requestAnimationFrame(step);
  }

  /* =========================
     BPM logic (per-deck) ‚Äî baseline 120
     ========================= */
  function onTempoInput(deck, bpm){
    const display = document.getElementById(`tempo${deck}-value`);
    if (display) display.textContent = String(Math.round(bpm));
    setDeckBpm(deck, parseFloat(bpm));
  }
  function setDeckBpm(deck, bpm){
    if (!bpm || isNaN(bpm)) bpm = 120;
    const rate = bpm / 120;
    const wrapper = deckWrappers[deck];
    if (wrapper && typeof wrapper.setPlaybackRate === 'function') wrapper.setPlaybackRate(rate);
    try { const audio = document.getElementById(`audio-deck${deck}`); if (audio) audio.playbackRate = rate; } catch(e){}
  }
  function resetDeckBpm(deck){
    const el = document.getElementById(`tempo${deck}`);
    if (el) { el.value = 120; document.getElementById(`tempo${deck}-value`).textContent = '120'; }
    setDeckBpm(deck, 120);
  }

  /* =========================
     Chatbot (minimal)
     ========================= */
  const chatHistory = [];
  const apiKeyForGen = 'AIzaSyDfWaNBq0S_A1iDyx4A71XGvpK4WCofCmU';
  async function sendMessage(){
    const input = document.getElementById('chat-input');
    const message = input && input.value.trim();
    if (!message) return;
    addMessage('You', message);
    input.value = '';
    const fullPrompt = `You are a DJ song recommender specializing in Bollywood/Hindi tracks and DJ mixes. Based on the query "${message}", suggest 5-10 unique songs or DJ mixes. Include DJ name if it's a mix, singer, and movie/album. Respond ONLY with a numbered list, each on a new line.`;
    chatHistory.push({ role:'user', parts:[{ text: fullPrompt }]});
    try {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKeyForGen}`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ contents: chatHistory, generationConfig:{ temperature:0.7, topK:1, topP:1, maxOutputTokens:512 } })});
      const data = await response.json();
      const aiResponse = data?.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';
      addMessage('AI', aiResponse);
    } catch (e){ console.error(e); addMessage('AI', 'Error: failed to get suggestions.'); }
  }
  function addMessage(sender, text){
    const m = document.getElementById('chat-messages');
    if (!m) return;
    const div = document.createElement('div');
    div.style.marginBottom = '8px';
    if (sender==='AI') div.innerHTML = `<strong>AI:</strong><div style="white-space:pre-wrap">${escapeHtml(text)}</div>`;
    else div.innerHTML = `<strong>You:</strong> ${escapeHtml(text)}`;
    m.appendChild(div); m.scrollTop = m.scrollHeight;
  }

  /* =========================
     Utilities & DOM helpers
     ========================= */
  function formatTime(t){ if (!t||isNaN(t)) return '0:00'; const s = Math.floor(t%60); const m = Math.floor(t/60); return m+':'+(s<10?'0'+s:s); }

  /* =========================
     Modal open/close helpers (robust)
     ========================= */
  function openModal(id){
    const el = document.getElementById(id);
    if (!el) return;
    el.style.display = 'flex';
    el.setAttribute('aria-hidden','false');
    // attach overlay click to close when clicked outside panel
    el.addEventListener('click', overlayClickHandler);
  }
  function closeModal(id){
    const el = document.getElementById(id);
    if (!el) return;
    el.style.display = 'none';
    el.setAttribute('aria-hidden','true');
    el.removeEventListener('click', overlayClickHandler);
  }
  function overlayClickHandler(e){
    // close if click on overlay (not inside panel)
    if (!e) return;
    const panel = this.querySelector('.panel');
    if (!panel) return;
    if (!panel.contains(e.target)) {
      this.style.display = 'none';
      this.setAttribute('aria-hidden','true');
      this.removeEventListener('click', overlayClickHandler);
    }
  }
  // ESC to close any open modal
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      ['history-modal','mp3-modal','notes-modal','chatbot-modal'].forEach(id => {
        const el = document.getElementById(id);
        if (el && el.style.display === 'flex') closeModal(id);
      });
    }
  });

  /* =========================
     Small bindings (buttons & init)
     ========================= */

  // Expose a few helper functions globally in case buttons call them externally
  window.openHistoryModal = function(){ openModal('history-modal'); };
  window.closeHistoryModal = function(){ closeModal('history-modal'); };
  window.openMp3Modal = function(){ refreshLocalList().then(()=> openModal('mp3-modal')).catch(()=>openModal('mp3-modal')); };
  window.closeMp3Modal = function(){ closeModal('mp3-modal'); };
  window.openNotesModal = function(){ openModal('notes-modal'); };
  window.closeNotesModal = function(){ closeModal('notes-modal'); };
  window.openChatbotModal = function(){ openModal('chatbot-modal'); };
  window.closeChatbotModal = function(){ closeModal('chatbot-modal'); };

  // Wire UI after DOM ready
  document.addEventListener('DOMContentLoaded', () => {
    // load YT
    loadYouTubeAPI();
    // init audio contexts
    initAudioContexts();

    // attach search buttons & enter keys
    document.getElementById('search-btn-1').addEventListener('click', ()=> searchYouTubeForDeck('deck1'));
    document.getElementById('search-btn-2').addEventListener('click', ()=> searchYouTubeForDeck('deck2'));
    document.getElementById('search-deck1').addEventListener('keydown', (e)=> { if (e.key==='Enter') searchYouTubeForDeck('deck1'); });
    document.getElementById('search-deck2').addEventListener('keydown', (e)=> { if (e.key==='Enter') searchYouTubeForDeck('deck2'); });

    // dropdown adapt on resize
    window.addEventListener('resize', ()=>{ adaptDropdownToPlayer(1); adaptDropdownToPlayer(2); });

    // BPM controls
    document.getElementById('tempo1').addEventListener('input', (e)=> onTempoInput(1, e.target.value));
    document.getElementById('tempo2').addEventListener('input', (e)=> onTempoInput(2, e.target.value));
    document.getElementById('reset-bpm-1').addEventListener('click', ()=> resetDeckBpm(1));
    document.getElementById('reset-bpm-2').addEventListener('click', ()=> resetDeckBpm(2));

    // deck audio controls hook-ups (safe)
    document.getElementById('deck1-volume').addEventListener('input', (e)=> deckSetVolume(1, e.target.value));
    document.getElementById('deck2-volume').addEventListener('input', (e)=> deckSetVolume(2, e.target.value));
    document.getElementById('deck1-seek').addEventListener('input', (e)=> deckSeekFromUI(1, e.target.value));
    document.getElementById('deck2-seek').addEventListener('input', (e)=> deckSeekFromUI(2, e.target.value));
    document.getElementById('deck1-playbtn').addEventListener('click', ()=> deckTogglePlay(1));
    document.getElementById('deck2-playbtn').addEventListener('click', ()=> deckTogglePlay(2));
    document.getElementById('deck1-lowcut').addEventListener('click', ()=> toggleLowCut(1));
    document.getElementById('deck2-lowcut').addEventListener('click', ()=> toggleLowCut(2));

    // balance & crossfade
    document.getElementById('balance-slider').addEventListener('input', onBalanceChange);
    document.getElementById('fade-a-b').addEventListener('click', ()=> smoothCrossfade(1,2,parseInt(document.getElementById('crossfade-duration').value||5000,10), { stopSource:true, respectBalanceSlider:document.getElementById('crossfade-respect-balance').checked }));
    document.getElementById('fade-b-a').addEventListener('click', ()=> smoothCrossfade(2,1,parseInt(document.getElementById('crossfade-duration').value||5000,10), { stopSource:true, respectBalanceSlider:document.getElementById('crossfade-respect-balance').checked }));
    document.getElementById('sync-btn').addEventListener('click', ()=> {
      const fromTempo = parseFloat(document.getElementById('tempo1')?.value || 120);
      const toTempo = parseFloat(document.getElementById('tempo2')?.value || 120);
      if (!fromTempo || !toTempo) return alert('Tempos missing');
      const rate = fromTempo / toTempo;
      deckWrappers[2].setPlaybackRate(rate);
      alert(`Deck 2 playbackRate set to ${rate.toFixed(3)}`);
    });

    // footer buttons & modal openers
    document.getElementById('open-history-btn').addEventListener('click', ()=> { openModal('history-modal'); });
    document.getElementById('open-mp3s-btn').addEventListener('click', ()=> { refreshLocalList().then(()=> openModal('mp3-modal')).catch(()=> openModal('mp3-modal')); });
    document.getElementById('play-last-btn').addEventListener('click', ()=> {
      database.ref('playedHistory').limitToLast(1).once('value').then(snap=>{
        const val = snap.val(); if (!val) return alert('No tracks in history');
        const key = Object.keys(val)[0]; const t = val[key];
        if (t && t.videoId) { deckWrappers[1].loadSource({ type:'youtube', videoId: t.videoId, title: t.title }); openModal('history-modal'); } else alert('No playable video');
      }).catch(()=>alert('Failed to fetch history'));
    });

    // notes/chatbot buttons
    document.getElementById('open-notes-btn').addEventListener('click', ()=> openModal('notes-modal'));
    document.getElementById('open-chat-btn').addEventListener('click', ()=> openModal('chatbot-modal'));
    document.getElementById('close-notes').addEventListener('click', ()=> closeModal('notes-modal'));
    document.getElementById('close-chat').addEventListener('click', ()=> closeModal('chatbot-modal'));
    document.getElementById('close-history').addEventListener('click', ()=> closeModal('history-modal'));
    document.getElementById('close-mp3').addEventListener('click', ()=> closeModal('mp3-modal'));
    document.getElementById('save-notes-btn').addEventListener('click', ()=> { const notes = document.getElementById('notes-textarea').value; database.ref('djNotes').set(notes); closeModal('notes-modal'); });

    // history modal buttons
    document.getElementById('history-backup').addEventListener('click', backupHistory);
    document.getElementById('history-restore').addEventListener('click', ()=> document.getElementById('restore-input').click());
    document.getElementById('restore-input').addEventListener('change', (e)=> { if (e.target.files[0]) restoreHistoryFromFile(e.target.files[0]); });
    document.getElementById('add-category-modal').addEventListener('click', ()=> {
      const name = (document.getElementById('new-category-input-modal')||{}).value || '';
      if (!name.trim()) return;
      if (!djCategories.includes(name)) database.ref('djCategories').set([...(djCategories||[]), name.trim()]);
      document.getElementById('new-category-input-modal').value = '';
    });
    document.getElementById('history-search-modal').addEventListener('input', filterHistoryModal);
    document.getElementById('category-filter-modal').addEventListener('change', filterHistoryModal);

    // mp3 modal buttons
    document.getElementById('mp3-refresh').addEventListener('click', refreshLocalList);
    document.getElementById('mp3-clear').addEventListener('click', ()=> { if (confirm('Delete all saved MP3s?')) clearAllLocalMp3s(); });

    // history/modal accessible close when clicking Escape handled earlier

    // Search dropdown adapt on open: attach click on player-area to hide dropdowns when clicking outside
    document.getElementById('player-area-1').addEventListener('click', (e)=> {
      // if clicked outside dropdown, hide it
      const dd = document.getElementById('custom-dropdown1');
      if (!dd) return;
      if (!dd.contains(e.target) && e.target.id !== 'search-deck1' && e.target.id !== 'search-btn-1') { dd.style.display='none'; dd.setAttribute('aria-hidden','true'); }
    });
    document.getElementById('player-area-2').addEventListener('click', (e)=> {
      const dd = document.getElementById('custom-dropdown2');
      if (!dd) return;
      if (!dd.contains(e.target) && e.target.id !== 'search-deck2' && e.target.id !== 'search-btn-2') { dd.style.display='none'; dd.setAttribute('aria-hidden','true'); }
    });

    // initialize values
    resetDeckBpm(1); resetDeckBpm(2);
    initListeners();
    refreshLocalList().catch(()=>{});
    adaptDropdownToPlayer(1); adaptDropdownToPlayer(2);
    // safety: periodically adapt dropdown width when window resizes
    window.addEventListener('resize', ()=> { adaptDropdownToPlayer(1); adaptDropdownToPlayer(2); });

  }); // DOMContentLoaded

  // small public utilities for debug (if you want)
  window.deckWrappers = deckWrappers;
  window.refreshLocalList = refreshLocalList;
  window.playLocalOnDeck = playLocalOnDeck;
  window.searchYouTubeForDeck = searchYouTubeForDeck;

})(); // end IIFE
</script>
</body>
</html>
